<!DOCTYPE html>
<html>
<head>
  <title>visual search task</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://unpkg.com/jspsych@7"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-instructions@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1"></script>
  <link href="https://unpkg.com/jspsych@7/css/jspsych.css" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />

  <!--
  <script type="text/javascript" src="lib/jspsych-7-pavlovia-2022.1.1.js"></script>
  -->

</head>
<body>
  <script>
    // Device detection - block mobile and tablet devices
    function isMobileOrTablet() {
      // Check user agent for common mobile/tablet indicators
      const userAgent = navigator.userAgent || navigator.vendor || window.opera;
      
      // Mobile device patterns (phones)
      const mobilePattern = /Android.*Mobile|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i;
      
      // Tablet patterns
      const tabletPattern = /iPad|Android(?!.*Mobile)|Tablet|PlayBook|Silk/i;
      
      // Check for touch-only devices with small screens (likely mobile)
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      const hasSmallScreen = window.screen.width < 768 && window.screen.height < 1024;
      
      // Return true if it's clearly a mobile or tablet
      if (mobilePattern.test(userAgent) || tabletPattern.test(userAgent)) {
        return true;
      }
      
      // Additional check: touch device with small screen is likely mobile
      if (isTouchDevice && hasSmallScreen) {
        return true;
      }
      
      return false;
    }

    // Check device and show warning if mobile/tablet
    if (isMobileOrTablet()) {
      // Clear the body and show warning
      document.body.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 20px; background-color: #f8f9fa;">
          <div style="max-width: 600px; background-color: white; padding: 40px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center;">
            <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
            <h1 style="color: #dc3545; margin-bottom: 20px; font-size: 24px;">お使いの端末では参加できません</h1>
            <p style="font-size: 18px; line-height: 1.6; color: #333; margin-bottom: 20px;">
              この実験はパソコンからのアクセスのみ対応しています。
            </p>
            <p style="font-size: 18px; line-height: 1.6; color: #333; margin-bottom: 30px;">
              <strong>パソコンから再度アクセスしてください。</strong>
            </p>
            <p style="font-size: 14px; color: #6c757d;">
              ご協力ありがとうございました。
            </p>
          </div>
        </div>
      `;
      // Prevent any further script execution
      throw new Error('Experiment access blocked: Mobile/Tablet device detected');
    }

    // Create required DOM elements for cognition.run deployment
    const targetDiv = document.createElement('div');
    targetDiv.id = 'jspsych-target';
    document.body.appendChild(targetDiv);

    const canvas = document.createElement('canvas');
    canvas.id = 'jspsych-visual-search-canvas';
    canvas.classList.add('hidden');
    document.body.appendChild(canvas);

    const searchWindowDiv = document.createElement('div');
    searchWindowDiv.id = 'search-window';
    searchWindowDiv.classList.add('hidden');
    document.body.appendChild(searchWindowDiv);

    // Initialize jsPsych v7 instance (upgraded from v6.3.1)
    // Note: Targeting v7.x as the latest stable version (v8.x may not be available yet)
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: function() {
        jsPsych.data.displayData();
      },
      on_trial_start: function() {
        // 各試行の開始時に、実験がフルスクリーンモードであることを確認
        if (!document.fullscreenElement && 
            !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && 
            !document.msFullscreenElement) {
          // フルスクリーンではない場合、再度要求（ブラウザによってはユーザー操作が必要）
          console.log("フルスクリーンモードの再確認");
        }
      }
    });

    // Automatically capture participant's screen resolution
    jsPsych.data.addProperties({
      screen_width: window.screen.width,
      screen_height: window.screen.height
    });

    // フルスクリーンモードを要求する関数
    function enterFullscreen() {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen().then(() => {
          console.log("フルスクリーンモードに正常に移行しました");
        }).catch(err => {
          console.warn("フルスクリーン移行エラー:", err);
        });
      } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      }
      
      // フォーカス管理を改善 - フォームの邪魔をしないようにする
      // setTimeout(() => {
      //   if (document.getElementById('jspsych-target')) {
      //     document.getElementById('jspsych-target').focus();
      //   }
      // }, 100);
    }

    // 実験開始時にフルスクリーンモードに自動的に移行するよう設定
    // ブラウザのセキュリティ制限のため、何らかのユーザー操作（キー入力など）に応じて実行する必要がある

    // ブラウザテスト用のデバッグ関数 (削除済み - イベントリスナーの競合を避けるため)
    // function testBrowserInteraction() {
    //   console.log("ブラウザテスト: キー入力のテスト");
    //   
    //   // キーボード入力のテスト
    //   window.addEventListener('keydown', function(e) {
    //     console.log("キー入力を検出:", e.key);
    //   });
    //   
    //   // カーソル操作のテスト
    //   document.addEventListener('mousemove', function(e) {
    //     // 大量のログを避けるため、100px移動ごとにログ
    //     if (e.clientX % 100 < 5 && e.clientY % 100 < 5) {
    //       console.log("カーソル位置:", e.clientX, e.clientY);
    //     }
    //   });
    //   
    //   console.log("ブラウザテスト: フルスクリーンの状態");
    //   if (document.fullscreenElement || 
    //       document.webkitFullscreenElement || 
    //       document.mozFullScreenElement || 
    //       document.msFullscreenElement) {
    //     console.log("現在フルスクリーンモード");
    //   } else {
    //     console.log("フルスクリーンモードではない");
    //   }
    // }
    
    // 実験開始時にテスト関数を実行 (削除済み)
    // window.addEventListener('load', function() {
    //   setTimeout(testBrowserInteraction, 2000);
    // });

    // Fullscreen management - only add listeners when needed to avoid conflicts with forms
    let fullscreenListenersActive = false;
    
    function addFullscreenListeners() {
      if (!fullscreenListenersActive) {
        // Add a small delay to ensure DOM is ready
        setTimeout(() => {
          document.addEventListener('fullscreenchange', handleFullscreenChange);
          document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
          document.addEventListener('mozfullscreenchange', handleFullscreenChange);
          document.addEventListener('MSFullscreenChange', handleFullscreenChange);
          fullscreenListenersActive = true;
        }, 50);
      }
    }
    
    function removeFullscreenListeners() {
      if (fullscreenListenersActive) {
        document.removeEventListener('fullscreenchange', handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
        document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
        fullscreenListenersActive = false;
      }
    }

    function handleFullscreenChange() {
      try {
        if (document.fullscreenElement || 
            document.webkitFullscreenElement || 
            document.mozFullScreenElement || 
            document.msFullscreenElement) {
          console.log("フルスクリーンモードに切り替わりました");
        } else {
          console.log("フルスクリーンモードから抜けました");
        }
      } catch (error) {
        console.warn("フルスクリーン状態の確認中にエラーが発生しました:", error);
      }
    }

    // Experiment parameters
    const params = {
      // Screen dimensions (will be updated at runtime)
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      
      // Window dimensions (approximately 1/9 of screen)
      windowWidth: Math.floor(window.innerWidth / 3),
      windowHeight: Math.floor(window.innerHeight / 3),
      
      // Objects
      numObjects: 25, // Total number of objects per trial
      objectSize: 40, // Fixed size for all objects
      
      // Target detection tolerance
      targetTolerance: 0.8, // Additional tolerance as multiplier of object size (0.8 = 80% of object size)
      
      // Placement
      maxPlacementAttempts: 10000, // Maximum attempts for random placement to avoid infinite loops
      
      // Colors and shapes
      colors: ['red', 'blue', 'green', 'yellow', 'purple'],
      shapes: ['circle', 'triangle', 'square', 'diamond'],
      
      // Trials
      trialsPerCondition: 15,
    };

    // Generate random object size within the specified range
    // Get fixed object size (all objects use the same size defined in params.objectSize)
    // All objects are consistently 40px in size
    function getObjectSize() {
      return params.objectSize;
    }

    // Get a representative size for target presentation (same as search objects)
    function getTargetPresentationSize() {
      return params.objectSize; // Same as search objects - 40px
    }

    // Trial factors
    // Structure conditions:
    // - 'structured': aligned grid layout (整列)
    // - 'aligned_random': 5×5 grid with random position within each cell (整列ランダム)
    // - 'blank_5': 5 random blank cells, 25 objects in remaining space (空白5個)
    // - 'blank_10': 10 random blank cells, 25 objects in remaining space (空白10個)
    const factors = {
      viewCondition: ['window', 'scroll', 'fullscreen'],
      structure: ['structured', 'aligned_random', 'blank_5', 'blank_10']
    };

    // Between-subjects random assignment of viewCondition
    // Each participant will only experience one of the three conditions
    const assignedViewCondition = jsPsych.randomization.sampleWithoutReplacement(
      factors.viewCondition, 1
    )[0];
    
    // Record the assigned view condition in experimental data
    jsPsych.data.addProperties({
      assigned_view_condition: assignedViewCondition
    });

    // Track mouse movements
    let mouseX = 0;
    let mouseY = 0;
    let mousePath = [];
    let totalMovement = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let isMouseDown = false;
    let currentDragDistance = 0; // Track drag distance for current interaction
    let justFinishedDrag = false; // Track if a drag operation just finished
    let dragOffsetX = 0; // Offset between cursor and window left edge when drag starts
    let dragOffsetY = 0; // Offset between cursor and window top edge when drag starts

    // Target and distractor objects
    let objects = [];
    let targetObject = null;
    
    // Blank cell tracking for blank_5 and blank_10 conditions
    let blankCellInfo = {
      blankCellSet: new Set(),
      gridSize: 5,
      cellWidth: 0,
      cellHeight: 0
    };
    
    // Blank cell dwell time tracking
    let blankCellDwellTime = 0;
    let lastBlankCheckTime = 0;
    let wasBlankCellVisible = false;

    // Trial progress tracking variables
    let currentMainTrialNumber = 0;
    const totalMainTrials = 60; // 1 viewCondition × 4 structures × 15 trialsPerCondition

    
    /* init connection with pavlovia.org */
    /*
    const pavlovia_init = {
      type: jsPsychPavlovia,
      command: "init"
    };
    */

    // Welcome screen
    const welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<h1>実験に参加していただきありがとうございます。</h1>' +
                '<p>下の「次へ」ボタンをクリックして実験を開始してください。</p>' +
                '<div style="margin: 20px 0;">' +
                '<button id="welcome-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">次へ</button>' +
                '</div>',
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during welcome
        removeFullscreenListeners();
        
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('welcome-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Informed consent screen
    const informedConsent = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; font-size: 14px;">';
        html += '<h1 style="text-align: center; color: #333; margin-bottom: 30px;">研究に関する同意事項</h1>';
        
        // Scrollable content area
        html += '<div id="consent-content" style="max-height: 500px; overflow-y: auto; border: 1px solid #ddd; padding: 20px; margin-bottom: 20px; background-color: #f9f9f9; text-align: left;">';
        
        html += '<h3>1. 研究の目的</h3>';
        html += '<p>本研究は、制限された視野を移動して行う視覚探索場面において、物体の配置構造が探索効率に与える影響を解明することを目的とします。</p>';
        
        html += '<h3>2. 実験内容</h3>';
        html += '<ul>';
        html += '<li>実施場所：実験に集中できる環境で参加してください。</li>';
        html += '<li>所要時間：10分〜15分程度</li>';
        html += '<li>課題内容：ご自身のPCからアクセスしていただき、画面上に表示される特定の図形の場所を探す課題に、繰り返し取り組んでいただきます。</li>';
        html += '<li>収集するデータ：ワーカー名、性別、年齢、反応時間、課題の成績、カーソルの移動履歴</li>';
        html += '</ul>';
        
        html += '<h3>3. 参加条件</h3>';
        html += '<ul>';
        html += '<li>18歳〜39歳の方。</li>';
        html += '<li>正常または矯正視力を有し、課題の理解に支障がない方。</li>';
        html += '<li>静かで落ち着いた場所から自身のPCを使って、オンラインで実験に参加できる方。</li>';
        html += '</ul>';
        
        html += '<h3>4. 予想される不利益・リスクと対処</h3>';
        html += '<ul>';
        html += '<li>画面注視による目の疲れ、ストレス等が生じる可能性があります。</li>';
        html += '<li>不快・体調不良時はいつでも中断・中止できます。</li>';
        html += '</ul>';
        
        html += '<h3>5. 研究成果の公開</h3>';
        html += '<p>この研究の成果は、博士論文および認知心理学関連の学会で発表を行う予定です。その際に収集したデータを公開することがありますが、情報から個人が特定されない形式での公開を行います。</p>';

        html += '<h3>6. 任意参加・撤回の自由</h3>';
        html += '<ul>';
        html += '<li>参加は完全に任意です。また理由を問わず、途中で撤回できます。</li>';
        html += '<li>参加を撤回した場合や途中で中止とした場合にも、不利益は一切ありません。</li>';
        html += '</ul>';
        
        html += '<h3>7. 個人情報とデータの取扱い</h3>';
        html += '<ul>';
        html += '<li>データはIDで管理し、個人識別情報と分離して保管します。</li>';
        html += '<li>データは研究実施者および指導教員のみが閲覧可能な状態で保存します。</li>';
        html += '<li>データの第三者提供は原則行いません。学会・論文等では統計的に集計した形で公表します。</li>';
        html += '<li>実験実施上で得られた個人情報等は、すべて守秘をお約束し、外部から閲覧不可の状態で厳重に管理いたします。</li>';
        html += '</ul>';
        
        html += '<h3>8. お問い合わせ先</h3>';
        html += '<p><strong>研究実施者：</strong>野﨑 優晴（東京学芸大学大学院 連合学校教育学研究科 博士課程）<br>';
        html += 'E-mail：r241004y@st.u-gakugei.ac.jp</p>';
        html += '<p><strong>指導教員：</strong>関口 貴裕（東京学芸大学 教育心理学講座 教授）<br>';
        html += 'E-mail：sekiguti@u-gakugei.ac.jp</p>';
        
        html += '</div>'; // End of scrollable content
        
        // Consent checkbox and button
        html += '<div style="text-align: center; margin: 20px 0;">';
        html += '<label style="display: flex; align-items: center; justify-content: center; font-size: 16px; margin-bottom: 20px;">';
        html += '<input type="checkbox" id="consent-checkbox" style="margin-right: 10px; transform: scale(1.2);"> ';
        html += '上記の内容を確認し、研究参加に同意します';
        html += '</label>';
        html += '<button id="consent-next-btn" disabled style="padding: 12px 24px; font-size: 16px; background-color: #ccc; color: #666; border: none; border-radius: 5px; cursor: not-allowed; transition: all 0.3s;">次へ進む</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during consent
        removeFullscreenListeners();
        
        const checkbox = document.getElementById('consent-checkbox');
        const nextBtn = document.getElementById('consent-next-btn');
        
        // Enable/disable button based on checkbox state
        checkbox.addEventListener('change', function() {
          if (checkbox.checked) {
            nextBtn.disabled = false;
            nextBtn.style.backgroundColor = '#007bff';
            nextBtn.style.color = 'white';
            nextBtn.style.cursor = 'pointer';
          } else {
            nextBtn.disabled = true;
            nextBtn.style.backgroundColor = '#ccc';
            nextBtn.style.color = '#666';
            nextBtn.style.cursor = 'not-allowed';
          }
        });
        
        // Add click event listener to the Next button
        nextBtn.addEventListener('click', function() {
          if (checkbox.checked) {
            // Record consent in jsPsych data
            jsPsych.data.addProperties({
              informed_consent: true,
              consent_timestamp: new Date().toISOString()
            });
            jsPsych.finishTrial();
          }
        });
      }
    };

    // Combined demographic information - Name, Email, Age, and Gender
    const demographics = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 700px; margin: 0 auto; padding: 20px; text-align: center; font-family: \'Noto Sans JP\', \'ヒラギノ角ゴ Pro\', \'Hiragino Kaku Gothic Pro\', \'メイリオ\', Meiryo, sans-serif;">';
        html += '<h2 style="margin-bottom: 30px; color: #333;">基本情報の入力</h2>';
        
        // Information about data usage
        html += '<div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin-bottom: 30px; text-align: left; line-height: 1.6;">';
        html += '<h4 style="color: #495057; margin-top: 0; margin-bottom: 15px;">個人情報の取り扱いについて</h4>';
        html += '<ul style="margin: 0; padding-left: 20px; color: #6c757d;">';
        html += '<li style="margin-bottom: 0;">入力いただいた情報は実験データとともに適切に管理いたします。</li>';
        html += '</ul>';
        html += '</div>';
        
        html += '<form id="demographics-form" style="margin: 20px 0;">';
        
        // Worker name field
        html += '<div style="margin: 20px 0; text-align: left;">';
        html += '<label for="worker-name" style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: bold;">ワーカー名 <span style="color: #dc3545;">*</span></label>';
        html += '<input type="text" id="worker-name" name="workerName" required style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box;" placeholder="ワーカー名を入力してください">';
        html += '</div>';
        
        // Age field
        html += '<div style="margin: 20px 0; text-align: left;">';
        html += '<label for="age-select" style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: bold;">年齢 <span style="color: #dc3545;">*</span></label>';
        html += '<p style="margin: 5px 0 10px 0; font-size: 14px; color: #6c757d;">対象年齢：18歳〜39歳</p>';
        html += '<select id="age-select" name="age" required style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box;">';
        html += '<option value="">選択してください</option>';

        // Generate age options from 18 to 39
        for (let i = 18; i <= 39; i++) {
          html += `<option value="${i}">${i}</option>`;
        }
        
        html += '</select>';
        html += '</div>';
        
        // Gender field
        html += '<div style="margin: 20px 0; text-align: left;">';
        html += '<label for="gender-select" style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: bold;">性別 <span style="color: #dc3545;">*</span></label>';
        html += '<select id="gender-select" name="gender" required style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box;">';
        html += '<option value="">選択してください</option>';
        html += '<option value="男性">男性</option>';
        html += '<option value="女性">女性</option>';
        html += '<option value="その他・答えたくない">その他・答えたくない</option>';
        html += '</select>';
        html += '</div>';
        
        html += '<div style="margin: 30px 0; text-align: center;">';
        html += '<button type="submit" style="padding: 12px 30px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">次へ進む</button>';
        html += '</div>';
        html += '</form>';
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during demographics
        removeFullscreenListeners();
        
        const form = document.getElementById('demographics-form');
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          
          const workerNameInput = document.getElementById('worker-name');
          const ageSelect = document.getElementById('age-select');
          const genderSelect = document.getElementById('gender-select');
          
          const workerName = workerNameInput.value.trim();
          const age = ageSelect.value;
          const gender = genderSelect.value;
          
          // Validate all fields
          if (!workerName) {
            alert('ワーカー名を入力してください。');
            workerNameInput.focus();
            return;
          }
          
          if (!age) {
            alert('年齢を選択してください。');
            ageSelect.focus();
            return;
          }
          
          if (!gender) {
            alert('性別を選択してください。');
            genderSelect.focus();
            return;
          }
          
          // Store all demographic data
          jsPsych.data.addProperties({
            worker_name: workerName,
            age: age,
            gender: gender
          });
          
          // Finish the trial with the collected data
          jsPsych.finishTrial({
            worker_name: workerName,
            age: age,
            gender: gender
          });
        });
      },
      on_finish: function() {
        // Fullscreen activation moved to check page
      }
    };

    // Check page for verifying participation conditions
    const checkPage = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 700px; margin: 0 auto; padding: 20px; text-align: center; font-family: \'Noto Sans JP\', \'ヒラギノ角ゴ Pro\', \'Hiragino Kaku Gothic Pro\', \'メイリオ\', Meiryo, sans-serif;">';
        html += '<h2 style="margin-bottom: 30px; color: #333;">参加条件の確認</h2>';
        
        // Information box
        html += '<div style="background-color: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 30px; text-align: left; line-height: 1.6;">';
        html += '<p style="margin: 0; font-size: 16px; color: #856404;">以下の条件をすべて満たしていることを確認してください。</p>';
        html += '</div>';
        
        // Checkboxes
        html += '<div style="text-align: left; margin: 20px 0;">';
        
        // Checkbox 1
        html += '<div style="margin: 20px 0; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">';
        html += '<label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 16px;">';
        html += '<input type="checkbox" id="check-1" class="check-item" style="margin-right: 10px; margin-top: 3px; transform: scale(1.3); cursor: pointer;"> ';
        html += '<span>スマートフォンやタブレット端末ではなく、パソコンで参加しています</span>';
        html += '</label>';
        html += '</div>';
        
        // Checkbox 2
        html += '<div style="margin: 20px 0; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">';
        html += '<label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 16px;">';
        html += '<input type="checkbox" id="check-2" class="check-item" style="margin-right: 10px; margin-top: 3px; transform: scale(1.3); cursor: pointer;"> ';
        html += '<span>画面タッチではなく、マウスやタッチパッドなどで操作しています</span>';
        html += '</label>';
        html += '</div>';
        
        // Checkbox 3
        html += '<div style="margin: 20px 0; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">';
        html += '<label style="display: flex; align-items: flex-start; cursor: pointer; font-size: 16px;">';
        html += '<input type="checkbox" id="check-3" class="check-item" style="margin-right: 10px; margin-top: 3px; transform: scale(1.3); cursor: pointer;"> ';
        html += '<span>集中して実験に取り組むことのできる場所で参加しています</span>';
        html += '</label>';
        html += '</div>';
        
        html += '</div>';
        
        // Next button
        html += '<div style="margin: 30px 0; text-align: center;">';
        html += '<button id="check-next-btn" disabled style="padding: 12px 30px; font-size: 16px; background-color: #ccc; color: #666; border: none; border-radius: 5px; cursor: not-allowed; font-weight: bold; transition: all 0.3s;">次へ進む</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during check page
        removeFullscreenListeners();
        
        const checkboxes = document.querySelectorAll('.check-item');
        const nextBtn = document.getElementById('check-next-btn');
        
        // Function to check if all checkboxes are checked
        function updateButtonState() {
          const allChecked = Array.from(checkboxes).every(cb => cb.checked);
          
          if (allChecked) {
            nextBtn.disabled = false;
            nextBtn.style.backgroundColor = '#007bff';
            nextBtn.style.color = 'white';
            nextBtn.style.cursor = 'pointer';
          } else {
            nextBtn.disabled = true;
            nextBtn.style.backgroundColor = '#ccc';
            nextBtn.style.color = '#666';
            nextBtn.style.cursor = 'not-allowed';
          }
        }
        
        // Add change event listeners to all checkboxes
        checkboxes.forEach(checkbox => {
          checkbox.addEventListener('change', updateButtonState);
        });
        
        // Add click event listener to the Next button
        nextBtn.addEventListener('click', function() {
          const allChecked = Array.from(checkboxes).every(cb => cb.checked);
          if (allChecked) {
            // Record check page completion
            jsPsych.data.addProperties({
              check_page_completed: true,
              check_page_timestamp: new Date().toISOString()
            });
            jsPsych.finishTrial();
          }
        });
      },
      on_finish: function() {
        // After check page is complete, activate fullscreen
        setTimeout(() => {
          addFullscreenListeners();
          enterFullscreen();
        }, 100);
      }
    };

    // Initial explanation page (simplified without memory tasks)
    const initialExplanation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 1100px; margin: 0 auto; padding: 40px; font-family: \'Noto Sans JP\', \'ヒラギノ角ゴ Pro\', \'Hiragino Kaku Gothic Pro\', \'メイリオ\', Meiryo, sans-serif; line-height: 1.8; background-color: #ffffff;">';
        
        // Title
        html += '<h1 style="text-align: center; color: #2c3e50; margin-bottom: 40px; font-size: 28px; font-weight: bold;">ルール説明（よく読んで始めてください）</h1>';
        
        // Get view condition
        const viewCondition = assignedViewCondition;
        
        // Operation flow overview (simplified without memory tasks)
        html += '<div style="background-color: #f8f9fa; border: 3px solid #dee2e6; border-radius: 12px; padding: 25px; margin-bottom: 30px;">';
        html += '<h2 style="color: #495057; margin-top: 0; font-size: 22px; text-align: center;">実験の流れ</h2>';
        html += '<div style="display: flex; justify-content: center; align-items: center; margin: 20px 0; flex-wrap: wrap; gap: 15px;">';
        html += '<div style="text-align: center; flex: 0 1 200px; background-color: #d1ecf1; padding: 15px; border-radius: 8px; border: 2px solid #bee5eb;">';
        html += '<div style="background-color: #0c5460; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; margin: 0 auto 10px; font-weight: bold;">1</div>';
        html += '<strong>ターゲット確認</strong><br>図形を覚える';
        html += '</div>';
        html += '<div style="font-size: 24px; color: #6c757d;">→</div>';
        html += '<div style="text-align: center; flex: 0 1 200px; background-color: #e3f2fd; padding: 15px; border-radius: 8px; border: 2px solid #2196f3;">';
        html += '<div style="background-color: #1976d2; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; margin: 0 auto 10px; font-weight: bold;">2</div>';
        html += '<strong>図形探索</strong><br>クリックで回答';
        html += '</div>';
        
        html += '</div>';
        html += '<p style="text-align: center; font-size: 18px; margin: 15px 0; color: #dc3545; font-weight: bold;">この流れを何度も繰り返します</p>';
        html += '</div>';
        
        // Target presentation with larger image
        html += '<div style="background-color: #d1ecf1; border: 2px solid #bee5eb; border-radius: 8px; padding: 25px; margin-bottom: 30px;">';
        html += '<h2 style="color: #0c5460; margin-top: 0; font-size: 22px;">【ステップ1】ターゲット図形の確認</h2>';
        html += '<div style="display: flex; gap: 30px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 350px;">';
        html += '<p style="font-size: 18px; margin: 15px 0;">まず、探す図形が<strong>1秒間</strong>表示されます。色と形をしっかり覚えてください。</p>';
        html += '<p style="font-size: 16px; margin: 10px 0; color: #0c5460;"><strong>重要：</strong> この図形を次の画面で見つけてクリックします。</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/1_target_presentation.png" alt="ターゲット図形の表示例" style="max-width: 400px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';

        // Display condition-specific explanation
        html += '<div style="margin-bottom: 30px;">';
        html += '<h2 style="color: #dc3545; font-size: 22px; margin-bottom: 20px;">【ステップ2】図形探索</h2>';
        
        // Use the previously defined viewCondition
        if (viewCondition === 'fullscreen') {
          // Fullscreen condition
          html += '<div style="background-color: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">';
          html += '<div style="display: flex; gap: 25px; align-items: center; flex-wrap: wrap;">';
          html += '<div style="flex: 1; min-width: 300px;">';
          html += '<p style="margin: 8px 0; font-size: 16px;"><strong>表示：</strong> 画面全体に図形が表示されます。</p>';
          html += '<p style="margin: 8px 0; font-size: 16px;"><strong>操作：</strong> 覚えた図形を見つけてクリックします。</p>';
          html += '</div>';
          html += '<div style="flex: 0 0 auto;">';
          html += '<img src="screen_shots/2_fullscreen.png" alt="全画面条件の例" style="max-width: 350px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
          html += '</div>';
          html += '</div>';
          html += '</div>';
        } else if (viewCondition === 'window') {
          // Window condition
          html += '<div style="background-color: #fff3e0; border: 2px solid #ff9800; border-radius: 8px; padding: 20px; margin-bottom: 20px;">';
          html += '<div style="display: flex; gap: 25px; align-items: center; flex-wrap: wrap;">';
          html += '<div style="flex: 1; min-width: 300px;">';
          html += '<p style="margin: 8px 0; font-size: 16px;"><strong>表示：</strong> 小さな四角型の「窓」から、図形がたくさん並んだ画面の一部をのぞきます。</p>';
          html += '<p style="margin: 8px 0; font-size: 16px;"><strong>操作：</strong> <strong>マウスなどをドラッグ</strong>して、「窓」を動かしながら、ターゲット図形を探してください。ターゲット図形を見つけたら、<strong>それをクリック</strong>してください。</p>';
          html += '</div>';
          html += '<div style="flex: 0 0 auto; display: flex; gap: 15px;">';
          html += '<img src="screen_shots/3_window_initial.png" alt="ウィンドウ条件（初期）" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
          html += '<img src="screen_shots/4_window_after_move.png" alt="ウィンドウ条件（移動後）" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
          html += '</div>';
          html += '</div>';
          html += '</div>';
        } else if (viewCondition === 'scroll') {
          // Scroll condition
          html += '<div style="background-color: #f3e5f5; border: 2px solid #9c27b0; border-radius: 8px; padding: 20px; margin-bottom: 20px;">';
          html += '<div style="display: flex; gap: 25px; align-items: center; flex-wrap: wrap;">';
          html += '<div style="flex: 1; min-width: 300px;">';
          html += '<p style="margin: 8px 0; font-size: 16px;"><strong>表示：</strong> 小さな四角型の「窓」から、図形がたくさん並んだ画面の一部をのぞきます。</p>';
          html += '<p style="margin: 8px 0; font-size: 16px;"><strong>操作：</strong> <strong>マウスなどをドラッグ</strong>して、「窓の下の画面」を動かしながら、ターゲット図形を探してください。ターゲット図形を見つけたら、<strong>それをクリック</strong>してください。</p>';
          html += '</div>';
          html += '<div style="flex: 0 0 auto; display: flex; gap: 15px;">';
          html += '<img src="screen_shots/5_scroll_initial.png" alt="スクロール条件（初期）" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
          html += '<img src="screen_shots/6_scroll_after_move.png" alt="スクロール条件（移動後）" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
          html += '</div>';
          html += '</div>';
          html += '</div>';
        }
        html += '</div>';

        // Final emphasis on repetition and speed/accuracy
        html += '<div style="background-color: #e8f5e8; border: 3px solid #4caf50; border-radius: 12px; padding: 25px; margin-bottom: 30px; text-align: center;">';
        html += '<h3 style="color: #2e7d32; margin: 0 0 15px 0; font-size: 20px;">実験の進行について</h3>';
        html += '<p style="font-size: 18px; margin: 10px 0; color: #2e7d32;">上記の2ステップを<strong>30回繰り返し</strong>ます。</p>';
        html += '<p style="font-size: 18px; margin: 10px 0; color: #2e7d32;">すべての試行で<strong>できるだけ早く、正確に</strong>回答することを心がけてください。</p>';
        html += '<p style="font-size: 18px; margin: 10px 0; color: #2e7d32;">はじめに練習を数回行うので、やり方を確認してください。</p>';
        html += '</div>';
        
        // Fullscreen notice
        html += '<div style="background-color: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 30px; text-align: center;">';
        html += '<p style="font-size: 18px; margin: 0 0 10px 0; color: #856404; font-weight: bold;">途中で実験をやめたくなったら</p>';
        html += '<p style="font-size: 16px; margin: 0; color: #856404;">実験中はウィンドウが全画面表示になります。途中で実験をやめたい場合は、<strong>ESCキー（エスケープキー）</strong>を押すことで全画面表示を解除できます。その上で、ブラウザを閉じてください。</p>';
        html += '</div>';
        
        // Continue button
        html += '<div style="text-align: center; margin-top: 40px;">';
        html += '<button id="initial-continue-btn" style="background-color: #007bff; color: white; border: none; padding: 20px 40px; font-size: 20px; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">練習に進む</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const continueBtn = document.getElementById('initial-continue-btn');
        continueBtn.addEventListener('click', function() {
          // Add fullscreen request before starting practice
          enterFullscreen();
          // Small delay to allow fullscreen transition
          setTimeout(() => {
            jsPsych.finishTrial();
          }, 500);
        });
      }
    };


    // Instructions for visual search task
    const visualSearchInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        const viewCondition = assignedViewCondition; // Use assigned condition instead of timeline variable
        const isPractice = jsPsych.timelineVariable('isPractice') || false;
        
        // Generate progress display for main trials only
        let progressDisplay = '';
        if (!isPractice) {
          // Increment trial counter for main trials
          currentMainTrialNumber++;
          
          // Calculate current search task statistics (excluding practice trials)
          const searchData = jsPsych.data.get().filter({task: 'visual_search', is_practice: false});
          let accuracyText = '';
          let avgSpeedText = '';
          
          if (searchData.count() > 0) {
            // Calculate accuracy percentage
            const correctSearches = searchData.filter({correct: true}).count();
            const accuracy = Math.round((correctSearches / searchData.count()) * 100);
            accuracyText = `<p style="font-size: 16px; margin: 5px 0; color: #333;">現在の成績：${accuracy}%正解</p>`;
            
            // Calculate average response time
            const searchTimes = searchData.select('reaction_time').values;
            const validTimes = searchTimes.filter(time => time != null && !isNaN(time) && time > 0);
            if (validTimes.length > 0) {
              const avgTime = validTimes.reduce((a, b) => a + b, 0) / validTimes.length;
              const avgTimeSec = (avgTime / 1000).toFixed(2); // 2 decimal places
              avgSpeedText = `<p style="font-size: 16px; margin: 5px 0; color: #333;">現在の平均スピード：${avgTimeSec}秒</p>`;
            }
          }
          
          progressDisplay = `<p style="font-size: 16px; margin: 10px 0; font-weight: bold; color: #007bff;">${currentMainTrialNumber}回/${totalMainTrials}回</p>${accuracyText}${avgSpeedText}`;
        }
        
        return `
          ${progressDisplay}
          <p><strong>下の「次へ」ボタンをクリックして開始します。</strong></p>
          <div style="margin: 20px 0;">
            <button id="visual-search-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">次へ</button>
          </div>
        `;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('visual-search-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };


    // Fixation point display
    const fixationPoint = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="display: flex; align-items: center; justify-content: center; height: 100vh;">
          <div style="font-size: 60px; font-weight: bold; color: black;">+</div>
        </div>
      `,
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: {
        task: 'fixation_point'
      }
    };

    // Blank screen display (500ms white screen)
    const blankScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background-color: white;">
        </div>
      `,
      choices: "NO_KEYS",
      trial_duration: 500,
      data: {
        task: 'blank_screen'
      }
    };

    // Display target object
    const showTarget = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Randomly select target color and shape
        const targetColor = jsPsych.randomization.sampleWithoutReplacement(params.colors, 1)[0];
        const targetShape = jsPsych.randomization.sampleWithoutReplacement(params.shapes, 1)[0];
        
        // Store in data for the visual search task
        jsPsych.data.addProperties({
          target_color: targetColor,
          target_shape: targetShape
        });
        
        return `
          <div style="margin: 20px auto; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;">
            <canvas id="target-canvas" width="60" height="60"></canvas>
          </div>
        `;
      },
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: {
        task: 'show_target'
      },
      on_load: function() {
        // Get target information from data
        const data = jsPsych.data.get().last(1).values()[0];
        const targetColor = data.target_color;
        const targetShape = data.target_shape;
        
        // Draw target on canvas using the same method as search objects
        const canvas = document.getElementById('target-canvas');
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw target object at center of canvas using same drawObject function
        drawObject(ctx, 30, 30, getTargetPresentationSize(), targetColor, targetShape);
      }
    };

    // Draw a shape on canvas or SVG
    function drawShape(shape, color, x, y, size) {
      const halfSize = size / 2;
      
      switch (shape) {
        case 'circle':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <circle cx="${halfSize}" cy="${halfSize}" r="${halfSize * 0.8}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'triangle':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <polygon points="${halfSize},${size * 0.2} ${size * 0.2},${size * 0.8} ${size * 0.8},${size * 0.8}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'square':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <rect x="${size * 0.2}" y="${size * 0.2}" width="${size * 0.6}" height="${size * 0.6}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'diamond':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <polygon points="${halfSize},${size * 0.2} ${size * 0.8},${halfSize} ${halfSize},${size * 0.8} ${size * 0.2},${halfSize}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        default:
          return `<svg width="${size}" height="${size}"><circle cx="${halfSize}" cy="${halfSize}" r="${halfSize}" fill="${color}" stroke="black" stroke-width="2" /></svg>`;
      }
    }

    // Visual search task
    const visualSearch = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        return `<div id="search-container" style="width: 100vw; height: 100vh;"></div>`;
      },
      choices: "NO_KEYS",
      data: {
        task: 'visual_search'
      },
      on_load: function() {
        // Get trial parameters - use assigned view condition instead of timeline variable
        const viewCondition = assignedViewCondition;
        const structure = jsPsych.timelineVariable('structure');
        
        // Capture practice variable early to ensure it is accessible
        const isPractice = jsPsych.timelineVariable('isPractice') || false;
        
        // Get target information
        const targetColor = jsPsych.data.get().last(1).values()[0].target_color;
        const targetShape = jsPsych.data.get().last(1).values()[0].target_shape;
        
        // Setup canvas
        const canvas = document.getElementById('jspsych-visual-search-canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.classList.remove('hidden');
        canvas.style.display = 'block';
        canvas.style.cursor = 'pointer'; // Only set cursor during visual search
        canvas.style.zIndex = '20'; // Set higher z-index during visual search
        canvas.style.pointerEvents = 'auto'; // Enable pointer events during visual search
        
        const ctx = canvas.getContext('2d');
        
        // Setup search window for window and scroll conditions
        const searchWindow = document.getElementById('search-window');
        if (viewCondition !== 'fullscreen') {
          searchWindow.style.width = params.windowWidth + 'px';
          searchWindow.style.height = params.windowHeight + 'px';
          searchWindow.classList.remove('hidden');
          searchWindow.style.display = 'block'; // Ensure search window is visible (reset from previous trial)
          // 中央に固定
          searchWindow.style.left = '50%';
          searchWindow.style.top = '50%';
          searchWindow.style.transform = 'translate(-50%, -50%)';
          
          // Enable pointer events for window condition to allow dragging
          if (viewCondition === 'window') {
            searchWindow.style.pointerEvents = 'auto';
          } else {
            searchWindow.style.pointerEvents = 'none';
          }
        }
        
        // Create visual search display
        const searchArea = {
          width: params.screenWidth,
          height: params.screenHeight
        };
        
        // Reset movement tracking
        mousePath = [];
        totalMovement = 0;
        currentDragDistance = 0; // Reset current drag distance for new trial
        justFinishedDrag = false; // Reset drag finish flag for new trial
        lastMouseX = params.screenWidth / 2;
        lastMouseY = params.screenHeight / 2;
        
        // Generate objects
        generateObjects(searchArea, targetColor, targetShape, structure, viewCondition, isPractice);
        
        // Initial draw
        drawSearchDisplay(ctx, viewCondition);
        
        // Start timer
        const startTime = performance.now();
        
        // Reset blank cell dwell time tracking
        blankCellDwellTime = 0;
        lastBlankCheckTime = performance.now();
        wasBlankCellVisible = false;
        
        // Set up periodic blank cell visibility check (every 50ms)
        let blankCellCheckInterval = null;
        if (viewCondition !== 'fullscreen' && (structure === 'blank_5' || structure === 'blank_10')) {
          blankCellCheckInterval = setInterval(() => {
            updateBlankCellDwellTime(performance.now(), viewCondition);
          }, 50);
        }
        
        // Store interval reference for cleanup
        const cleanupBlankCellInterval = () => {
          if (blankCellCheckInterval !== null) {
            clearInterval(blankCellCheckInterval);
            blankCellCheckInterval = null;
          }
        };
        
        // Define instruction management functions in outer scope
        let hideInstruction = function() {};
        let showInstruction = function() {};
        let updateInstructionPosition = function() {};
        
        // Add practice instruction display for window and scroll conditions
        let instructionElement = null;
        if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
          // Create instruction element
          instructionElement = document.createElement('div');
          instructionElement.id = 'practice-instruction';
          instructionElement.style.position = 'fixed';
          instructionElement.style.left = '50%';
          instructionElement.style.transform = 'translateX(-50%)';
          instructionElement.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
          instructionElement.style.padding = '20px 30px';
          instructionElement.style.borderRadius = '10px';
          instructionElement.style.border = '2px solid #007bff';
          instructionElement.style.fontSize = '18px';
          instructionElement.style.fontWeight = 'bold';
          instructionElement.style.color = '#333';
          instructionElement.style.zIndex = '100';
          instructionElement.style.maxWidth = '800px';
          instructionElement.style.textAlign = 'center';
          instructionElement.style.lineHeight = '1.6';
          instructionElement.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
          instructionElement.style.transition = 'opacity 0.3s ease, top 0.3s ease, bottom 0.3s ease';
          
          // Set instruction text based on condition
          if (viewCondition === 'window') {
            instructionElement.textContent = 'マウスのボタンを押したまま、窓をドラッグすることで、窓を動かすことができます。ターゲットの図形を見つけたら、クリックしてください。';
          } else if (viewCondition === 'scroll') {
            instructionElement.textContent = 'マウスのボタンを押したまま、窓の外まで大きくドラッグすることで、窓の下にある画面全体を動かせます。ターゲットの図形を見つけたら、クリックしてください。';
          }
          
          document.body.appendChild(instructionElement);
          
          // Function to update instruction position based on window overlap
          updateInstructionPosition = function() {
            if (!instructionElement) return;
            
            const windowRect = searchWindow.getBoundingClientRect();
            const instructionHeight = instructionElement.offsetHeight;
            const screenHeight = window.innerHeight;
            
            // Default position: bottom of screen
            const bottomPosition = 30;
            const topPosition = 30;
            
            // Check if instruction at bottom would overlap with window
            const instructionBottomY = screenHeight - bottomPosition - instructionHeight;
            const windowBottomY = windowRect.bottom;
            const windowTopY = windowRect.top;
            
            // If window overlaps with bottom position, move to top
            if (instructionBottomY < windowBottomY && instructionBottomY + instructionHeight > windowTopY) {
              instructionElement.style.top = topPosition + 'px';
              instructionElement.style.bottom = 'auto';
            } else {
              instructionElement.style.bottom = bottomPosition + 'px';
              instructionElement.style.top = 'auto';
            }
          };
          
          // Initial position
          updateInstructionPosition();
          
          // Function to hide instruction
          hideInstruction = function() {
            if (instructionElement) {
              instructionElement.style.opacity = '0';
            }
          };
          
          // Function to show instruction
          showInstruction = function() {
            if (instructionElement) {
              updateInstructionPosition();
              instructionElement.style.opacity = '1';
            }
          };
        }
        
        // Setup event listeners
        if (viewCondition === 'window') {
          // Window condition - drag to move the window
          searchWindow.addEventListener('mousedown', startWindowDrag);
          document.addEventListener('mousemove', dragWindow);
          document.addEventListener('mouseup', endWindowDrag);
          // Add click event listener to search window for object selection
          searchWindow.addEventListener('click', checkSelection);
        } else if (viewCondition === 'scroll') {
          // Scroll condition - drag the background
          canvas.addEventListener('mousedown', startDrag);
          document.addEventListener('mousemove', dragBackground);
          document.addEventListener('mouseup', endDrag);
        }
        
        // Click to select object (for fullscreen and scroll conditions)
        if (viewCondition !== 'window') {
          canvas.addEventListener('click', checkSelection);
        }
        
        // Event handler functions
        function startWindowDrag(e) {
          // Only start drag if clicking within the window
          isMouseDown = true;
          mouseX = e.clientX;
          mouseY = e.clientY;
          lastMouseX = mouseX;
          lastMouseY = mouseY;
          currentDragDistance = 0; // Reset drag distance for new interaction
          
          // Hide instruction when drag starts
          hideInstruction();
          
          // Calculate offset between cursor and window position
          const searchWindow = document.getElementById('search-window');
          const windowRect = searchWindow.getBoundingClientRect();
          
          // Remove CSS transform and set absolute positioning
          searchWindow.style.transform = 'none';
          searchWindow.style.left = windowRect.left + 'px';
          searchWindow.style.top = windowRect.top + 'px';
          
          // Now calculate the offset with the corrected position
          dragOffsetX = mouseX - windowRect.left;
          dragOffsetY = mouseY - windowRect.top;
        }
        
        function dragWindow(e) {
          if (!isMouseDown && viewCondition === 'window') return; // Only move during drag
          
          mouseX = e.clientX;
          mouseY = e.clientY;
          
          if (viewCondition === 'window' && isMouseDown) {
            // Calculate movement distance
            const dx = mouseX - lastMouseX;
            const dy = mouseY - lastMouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Update total movement and path
            totalMovement += distance;
            currentDragDistance += distance; // Track current interaction drag distance
            mousePath.push({x: mouseX, y: mouseY, time: performance.now() - startTime});
            
            // Update last position
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Move the window using the stored offset
            let windowX = mouseX - dragOffsetX;
            let windowY = mouseY - dragOffsetY;
            
            // Keep window within screen bounds
            windowX = Math.max(0, Math.min(windowX, params.screenWidth - params.windowWidth));
            windowY = Math.max(0, Math.min(windowY, params.screenHeight - params.windowHeight));
            
            searchWindow.style.left = windowX + 'px';
            searchWindow.style.top = windowY + 'px';
            
            // Update canvas clip region
            drawSearchDisplay(ctx, viewCondition);
            
            // Update blank cell dwell time
            updateBlankCellDwellTime(performance.now(), viewCondition);
          }
        }
        
        function endWindowDrag() {
          isMouseDown = false;
          
          // Show instruction when drag ends
          showInstruction();
          
          // If there was significant drag, mark it to prevent immediate clicks
          if (currentDragDistance > 5) {
            justFinishedDrag = true;
            setTimeout(() => {
              justFinishedDrag = false;
            }, 50); // Small delay to prevent click events immediately after drag
          }
        }
        
        function startDrag(e) {
          isMouseDown = true;
          mouseX = e.clientX;
          mouseY = e.clientY;
          lastMouseX = mouseX;
          lastMouseY = mouseY;
          currentDragDistance = 0; // Reset drag distance for new interaction
          
          // Hide instruction when drag starts
          hideInstruction();
        }
        
        function dragBackground(e) {
          if (!isMouseDown && viewCondition === 'scroll') return;
          
          mouseX = e.clientX;
          mouseY = e.clientY;
          
          if (viewCondition === 'scroll' && isMouseDown) {
            // Calculate movement distance
            const dx = mouseX - lastMouseX;
            const dy = mouseY - lastMouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Update total movement and path
            totalMovement += distance;
            currentDragDistance += distance; // Track current interaction drag distance
            mousePath.push({x: mouseX, y: mouseY, time: performance.now() - startTime});
            
            // Move all objects
            for (let i = 0; i < objects.length; i++) {
              objects[i].x += dx;
              objects[i].y += dy;
            }
            
            // Track scroll offset for blank cell visibility calculation
            scrollOffsetX += dx;
            scrollOffsetY += dy;
            
            // Update last position
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Redraw
            drawSearchDisplay(ctx, viewCondition);
            
            // Update blank cell dwell time
            updateBlankCellDwellTime(performance.now(), viewCondition);
          }
        }
        
        function endDrag() {
          isMouseDown = false;
          
          // Show instruction when drag ends
          showInstruction();
        }
        
        function checkSelection(e) {
          const clickX = e.clientX;
          const clickY = e.clientY;
          
          // For scroll/window conditions, check if significant dragging occurred
          // If user dragged more than 5 pixels, don't treat this as a selection click
          if ((viewCondition === 'scroll' || viewCondition === 'window') && (currentDragDistance > 5 || justFinishedDrag)) {
            return; // Ignore click after significant drag or immediately after drag
          }
          
          // Check if click is within visible area for window/scroll conditions
          if (viewCondition !== 'fullscreen') {
            const windowRect = searchWindow.getBoundingClientRect();
            if (clickX < windowRect.left || clickX > windowRect.right || 
                clickY < windowRect.top || clickY > windowRect.bottom) {
              return; // Click outside visible area
            }
          }
          
          // Find clicked object using standard collision detection
          let clickedObject = null;
          
          for (let i = 0; i < objects.length; i++) {
            const obj = objects[i];
            const dx = clickX - obj.x;
            const dy = clickY - obj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= obj.size / 2) {
              clickedObject = obj;
              break;
            }
          }
          
          // If no object was clicked using standard detection, check for expanded target detection
          if (!clickedObject && targetObject) {
            const targetDx = clickX - targetObject.x;
            const targetDy = clickY - targetObject.y;
            const targetDistance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            // Calculate expanded hit radius for target
            const expandedTargetRadius = (targetObject.size / 2) + (targetObject.size * params.targetTolerance);
            
            if (targetDistance <= expandedTargetRadius) {
              clickedObject = targetObject;
            }
          }
          
          // Check if target was found
          const correct = clickedObject === targetObject;
          const rt = performance.now() - startTime;
          
          // Final update of blank cell dwell time and cleanup interval
          cleanupBlankCellInterval();
          updateBlankCellDwellTime(performance.now(), viewCondition);
          
          // Calculate layout entropy
          const layoutEntropy = calculateLayoutEntropy(searchArea, objects);
          
          // Calculate blank cell dwell time ratio (0 for fullscreen or when rt is 0)
          const blankCellDwellRatio = rt > 0 ? blankCellDwellTime / rt : 0;
          
          // Remove event listeners
          if (viewCondition === 'window') {
            searchWindow.removeEventListener('mousedown', startWindowDrag);
            document.removeEventListener('mousemove', dragWindow);
            document.removeEventListener('mouseup', endWindowDrag);
            searchWindow.removeEventListener('click', checkSelection);
            // Reset pointer events for search window
            searchWindow.style.pointerEvents = 'none';
          } else if (viewCondition === 'scroll') {
            canvas.removeEventListener('mousedown', startDrag);
            document.removeEventListener('mousemove', dragBackground);
            document.removeEventListener('mouseup', endDrag);
          }
          
          if (viewCondition !== 'window') {
            canvas.removeEventListener('click', checkSelection);
          }
          
          // Reset drag state
          isMouseDown = false;
          justFinishedDrag = false;
          
          // Remove practice instruction element if it exists
          if (instructionElement) {
            instructionElement.remove();
            instructionElement = null;
          }
          
          // Hide canvas and window immediately using direct style property
          canvas.style.display = 'none';
          canvas.style.cursor = 'default'; // Reset cursor
          canvas.style.zIndex = '5'; // Reset z-index
          canvas.style.pointerEvents = 'none'; // Disable pointer events
          searchWindow.style.display = 'none';
          
          // Finish trial
          const isPracticeCondition = isPractice;
          const trialData = {
            reaction_time: rt,
            correct: correct,
            view_condition: viewCondition,
            structure: structure,
            practice_trial: isPracticeCondition,
            target_color: targetColor,
            target_shape: targetShape,
            total_movement: totalMovement,
            mouse_path: mousePath,
            task: 'visual_search',
            is_practice: isPractice,
            blank_cell_dwell_time: blankCellDwellTime,
            blank_cell_dwell_ratio: blankCellDwellRatio,
            layout_entropy: layoutEntropy
          };
          
          // Only save data if not in practice mode
          if (!isPractice) {
            jsPsych.finishTrial(trialData);
          } else {
            // For practice, still finish trial but don't save to main data
            jsPsych.finishTrial(trialData);
          }
        }
      }
    };

    // Generate objects for visual search
    function generateObjects(area, targetColor, targetShape, structure, viewCondition, isPractice) {
      objects = [];
      let positions = [];
      
      // Reset blank cell info (will be populated for blank_5 and blank_10)
      blankCellInfo = {
        blankCellSet: new Set(),
        gridSize: 5,
        cellWidth: area.width / 5,
        cellHeight: area.height / 5
      };
      
      // Reset scroll offset
      scrollOffsetX = 0;
      scrollOffsetY = 0;
      
      // Use fixed object size for positioning calculations (to avoid overlaps)
      const avgObjectSize = params.objectSize;
      
      let targetX, targetY;
      
      // Calculate initial window bounds for practice trials
      let initialWindowBounds = null;
      if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
        // Initial window is centered on screen
        const windowCenterX = params.screenWidth / 2;
        const windowCenterY = params.screenHeight / 2;
        initialWindowBounds = {
          left: windowCenterX - params.windowWidth / 2,
          right: windowCenterX + params.windowWidth / 2,
          top: windowCenterY - params.windowHeight / 2,
          bottom: windowCenterY + params.windowHeight / 2
        };
      }
      
      // Helper function to check if target overlaps with initial window
      function isTargetInInitialWindow(x, y) {
        if (!initialWindowBounds) return false;
        
        // Check if target center is within window bounds
        // Add some padding to account for object size
        const padding = avgObjectSize / 2;
        return (x + padding > initialWindowBounds.left && 
                x - padding < initialWindowBounds.right &&
                y + padding > initialWindowBounds.top && 
                y - padding < initialWindowBounds.bottom);
      }
      
      if (structure === 'structured') {
        // For structured condition, create a grid layout
        const gridSize = Math.floor(Math.sqrt(params.numObjects));
        const cellWidth = area.width / gridSize;
        const cellHeight = area.height / gridSize;
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            positions.push({
              x: i * cellWidth + cellWidth / 2,
              y: j * cellHeight + cellHeight / 2
            });
          }
        }
        
        // For practice trials, filter out positions that would be in the initial window
        let availablePositions = positions;
        if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
          availablePositions = positions.filter(pos => !isTargetInInitialWindow(pos.x, pos.y));
          
          // If no positions are available outside the window, use all positions as fallback
          if (availablePositions.length === 0) {
            availablePositions = positions;
          }
        }
        
        // Randomly place target at one of the available positions
        const targetPosition = Math.floor(Math.random() * availablePositions.length);
        targetX = availablePositions[targetPosition].x;
        targetY = availablePositions[targetPosition].y;
        
        // Remove the target position from the original positions array
        const originalTargetIndex = positions.findIndex(pos => pos.x === targetX && pos.y === targetY);
        if (originalTargetIndex >= 0) {
          positions.splice(originalTargetIndex, 1);
        }
      } else if (structure === 'aligned_random') {
        // Aligned random condition (整列ランダム) - grid-based random positions
        // Divide the area into a 5×5 grid, and place each object at a random position within its cell
        const gridSize = 5;
        const cellWidth = area.width / gridSize;
        const cellHeight = area.height / gridSize;
        
        // Padding to keep objects from touching cell edges
        const padding = avgObjectSize / 2;
        
        // Generate all cell positions (25 cells for 25 objects)
        let allCellPositions = [];
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            // Generate a random position within this cell
            const cellLeft = i * cellWidth + padding;
            const cellRight = (i + 1) * cellWidth - padding;
            const cellTop = j * cellHeight + padding;
            const cellBottom = (j + 1) * cellHeight - padding;
            
            // Ensure the random range is valid
            const x = cellLeft + Math.random() * Math.max(0, cellRight - cellLeft);
            const y = cellTop + Math.random() * Math.max(0, cellBottom - cellTop);
            
            allCellPositions.push({ x: x, y: y, cellIndex: i * gridSize + j });
          }
        }
        
        // Shuffle the positions to randomize which cell gets the target
        allCellPositions = jsPsych.randomization.shuffle(allCellPositions);
        
        // For practice trials, filter out positions that would be in the initial window for target selection
        let availableTargetPositions = allCellPositions;
        if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
          availableTargetPositions = allCellPositions.filter(pos => !isTargetInInitialWindow(pos.x, pos.y));
          
          // If no positions are available outside the window, use all positions as fallback
          if (availableTargetPositions.length === 0) {
            availableTargetPositions = allCellPositions;
          }
        }
        
        // Select target position from available positions
        const targetPositionIndex = Math.floor(Math.random() * availableTargetPositions.length);
        const targetPos = availableTargetPositions[targetPositionIndex];
        targetX = targetPos.x;
        targetY = targetPos.y;
        
        // Remove the target position from all positions and use remaining for distractors
        const targetCellIndex = targetPos.cellIndex;
        for (let i = 0; i < allCellPositions.length; i++) {
          if (allCellPositions[i].cellIndex !== targetCellIndex) {
            positions.push({ x: allCellPositions[i].x, y: allCellPositions[i].y });
          }
        }
      } else if (structure === 'blank_5' || structure === 'blank_10') {
        // Blank cell conditions (空白5個 or 空白10個)
        // Divide the area into a 5×5 grid, randomly select n cells to be blank,
        // then randomly place 25 objects in the remaining space
        const gridSize = 5;
        const cellWidth = area.width / gridSize;
        const cellHeight = area.height / gridSize;
        const numBlankCells = structure === 'blank_5' ? 5 : 10;
        
        // Padding to keep objects from touching edges
        const padding = avgObjectSize / 2;
        
        // Create list of all cell indices (0-24)
        const allCellIndices = [];
        for (let i = 0; i < gridSize * gridSize; i++) {
          allCellIndices.push(i);
        }
        
        // Randomly select blank cells
        const blankCellIndices = jsPsych.randomization.sampleWithoutReplacement(allCellIndices, numBlankCells);
        const blankCellSet = new Set(blankCellIndices);
        
        // Store blank cell info for dwell time tracking
        blankCellInfo = {
          blankCellSet: blankCellSet,
          gridSize: gridSize,
          cellWidth: cellWidth,
          cellHeight: cellHeight
        };
        
        // Helper function to check if a position is inside a blank cell
        function isInBlankCell(x, y) {
          const cellCol = Math.floor(x / cellWidth);
          const cellRow = Math.floor(y / cellHeight);
          // Clamp to valid grid range
          const clampedCol = Math.max(0, Math.min(gridSize - 1, cellCol));
          const clampedRow = Math.max(0, Math.min(gridSize - 1, cellRow));
          const cellIndex = clampedCol * gridSize + clampedRow;
          return blankCellSet.has(cellIndex);
        }
        
        // Calculate the valid placement area (overall area with padding)
        const minX = padding;
        const maxX = area.width - padding;
        const minY = padding;
        const maxY = area.height - padding;
        
        // Generate 25 random positions, ensuring no overlaps and avoiding blank cell centers
        const allPositions = [];
        const minDistance = avgObjectSize; // Minimum distance between object centers to avoid overlap
        const maxAttempts = params.maxPlacementAttempts;
        let attempts = 0;
        
        while (allPositions.length < params.numObjects && attempts < maxAttempts) {
          attempts++;
          
          // Generate random position within the valid area
          const x = minX + Math.random() * (maxX - minX);
          const y = minY + Math.random() * (maxY - minY);
          
          // Check if this position's center is in a blank cell
          if (isInBlankCell(x, y)) {
            continue;
          }
          
          // Check for overlap with existing positions
          let hasOverlap = false;
          for (let i = 0; i < allPositions.length; i++) {
            const dx = x - allPositions[i].x;
            const dy = y - allPositions[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < minDistance) {
              hasOverlap = true;
              break;
            }
          }
          
          if (!hasOverlap) {
            allPositions.push({ x: x, y: y });
          }
        }
        
        // For practice trials, filter out positions that would be in the initial window for target selection
        let availableTargetPositions = allPositions;
        if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
          availableTargetPositions = allPositions.filter(pos => !isTargetInInitialWindow(pos.x, pos.y));
          
          // If no positions are available outside the window, use all positions as fallback
          if (availableTargetPositions.length === 0) {
            availableTargetPositions = allPositions;
          }
        }
        
        // Select target position from available positions
        const targetPositionIndex = Math.floor(Math.random() * availableTargetPositions.length);
        const targetPos = availableTargetPositions[targetPositionIndex];
        targetX = targetPos.x;
        targetY = targetPos.y;
        
        // Use remaining positions for distractors
        for (let i = 0; i < allPositions.length; i++) {
          if (allPositions[i].x !== targetPos.x || allPositions[i].y !== targetPos.y) {
            positions.push({ x: allPositions[i].x, y: allPositions[i].y });
          }
        }
      }
      
      // Create the target object
      targetObject = {
        x: targetX,
        y: targetY,
        size: getObjectSize(),
        color: targetColor,
        shape: targetShape,
        isTarget: true
      };
      
      objects.push(targetObject);
      
      // Create distractor objects
      for (let i = 0; i < params.numObjects - 1; i++) {
        if (i >= positions.length) break;
        
        let distractorColor, distractorShape;
        
        // Ensure at least one feature is different from target
        if (Math.random() < 0.5) {
          // Different color, same shape
          distractorColor = jsPsych.randomization.sampleWithoutReplacement(
            params.colors.filter(c => c !== targetColor), 1)[0];
          distractorShape = targetShape;
        } else {
          // Same color, different shape
          distractorColor = targetColor;
          distractorShape = jsPsych.randomization.sampleWithoutReplacement(
            params.shapes.filter(s => s !== targetShape), 1)[0];
        }
        
        // Some distractors might differ in both features
        if (Math.random() < 0.3) {
          distractorColor = jsPsych.randomization.sampleWithoutReplacement(
            params.colors.filter(c => c !== targetColor), 1)[0];
          distractorShape = jsPsych.randomization.sampleWithoutReplacement(
            params.shapes.filter(s => s !== targetShape), 1)[0];
        }
        
        objects.push({
          x: positions[i].x,
          y: positions[i].y,
          size: getObjectSize(),
          color: distractorColor,
          shape: distractorShape,
          isTarget: false
        });
      }
    }

    // Calculate layout entropy based on object positions in a 5x5 grid
    // E = -sum_i(n_i * log(n_i)) where n_i is the count of shapes in cell i
    // Note: For scroll condition, we need to use original positions (subtract scrollOffset)
    function calculateLayoutEntropy(area, objectsList) {
      const gridSize = 5;
      const cellWidth = area.width / gridSize;
      const cellHeight = area.height / gridSize;
      
      // Count objects per cell (based on object center position)
      const cellCounts = new Array(gridSize * gridSize).fill(0);
      
      for (let i = 0; i < objectsList.length; i++) {
        const obj = objectsList[i];
        // Use original positions (subtract scroll offset for scroll condition)
        const originalX = obj.x - scrollOffsetX;
        const originalY = obj.y - scrollOffsetY;
        
        const cellCol = Math.floor(originalX / cellWidth);
        const cellRow = Math.floor(originalY / cellHeight);
        
        // Clamp to valid grid range
        const clampedCol = Math.max(0, Math.min(gridSize - 1, cellCol));
        const clampedRow = Math.max(0, Math.min(gridSize - 1, cellRow));
        const cellIndex = clampedCol * gridSize + clampedRow;
        
        cellCounts[cellIndex]++;
      }
      
      // Calculate entropy: E = -sum_i(n_i * log(n_i))
      // Note: We use log base e (natural log) and handle n_i = 0 (0 * log(0) = 0 by convention)
      let entropy = 0;
      for (let i = 0; i < cellCounts.length; i++) {
        const n = cellCounts[i];
        if (n > 0) {
          entropy -= n * Math.log(n);
        }
      }
      
      return entropy;
    }

    // Check if any blank cell is visible in the window (more than 50% of cell area visible)
    // Returns true if at least one blank cell is more than 50% visible
    function isBlankCellVisible(viewCondition) {
      // Only relevant for window and scroll conditions with blank cells
      if (viewCondition === 'fullscreen' || blankCellInfo.blankCellSet.size === 0) {
        return false;
      }
      
      const searchWindow = document.getElementById('search-window');
      if (!searchWindow) return false;
      
      const windowRect = searchWindow.getBoundingClientRect();
      const gridSize = blankCellInfo.gridSize;
      const cellWidth = blankCellInfo.cellWidth;
      const cellHeight = blankCellInfo.cellHeight;
      
      // For scroll condition, we need to calculate the offset of the objects
      // The objects have been moved, so we need to determine the current viewport position
      let offsetX = 0;
      let offsetY = 0;
      
      if (viewCondition === 'scroll' && objects.length > 0 && targetObject) {
        // Calculate how much the objects have moved from their original positions
        // We track this by comparing original target position (stored) with current position
        // For scroll, objects move, so we need to determine the viewport offset
        // The cell positions are in original screen coordinates
        // Objects have been translated, so cell positions need the same translation
        
        // Actually, for scroll condition, the objects move relative to their original positions
        // The blank cells are defined in the original coordinate system
        // We need to offset the blank cell positions by the same amount objects have moved
        offsetX = 0;
        offsetY = 0;
      }
      
      // Check each blank cell for visibility
      for (const cellIndex of blankCellInfo.blankCellSet) {
        const cellCol = Math.floor(cellIndex / gridSize);
        const cellRow = cellIndex % gridSize;
        
        // Calculate cell boundaries in screen coordinates
        let cellLeft = cellCol * cellWidth + offsetX;
        let cellRight = cellLeft + cellWidth;
        let cellTop = cellRow * cellHeight + offsetY;
        let cellBottom = cellTop + cellHeight;
        
        // For scroll condition, adjust cell position based on object movement
        if (viewCondition === 'scroll' && objects.length > 0) {
          // The first object's original position was determined during generation
          // We can estimate the scroll offset by comparing where objects are now vs original grid
          // Since all objects move together, we can use any object to estimate the offset
          // However, we need to track the original positions - let's use a simpler approach:
          // The visible area in original coordinates is the area that would be visible
          // after reverse-translating by the scroll amount
          
          // For scroll, the window is fixed at center, but objects move
          // So to check if a blank cell is visible, we need to see if the cell
          // (after being translated with the objects) intersects the window
          
          // We'll track scroll offset in the generateObjects function
          cellLeft += scrollOffsetX;
          cellRight += scrollOffsetX;
          cellTop += scrollOffsetY;
          cellBottom += scrollOffsetY;
        }
        
        // Calculate intersection area
        const intersectLeft = Math.max(cellLeft, windowRect.left);
        const intersectRight = Math.min(cellRight, windowRect.right);
        const intersectTop = Math.max(cellTop, windowRect.top);
        const intersectBottom = Math.min(cellBottom, windowRect.bottom);
        
        if (intersectRight > intersectLeft && intersectBottom > intersectTop) {
          const intersectionArea = (intersectRight - intersectLeft) * (intersectBottom - intersectTop);
          const cellArea = cellWidth * cellHeight;
          
          // Check if more than 50% of the cell is visible
          if (intersectionArea > cellArea * 0.5) {
            return true;
          }
        }
      }
      
      return false;
    }

    // Update blank cell dwell time based on current visibility
    function updateBlankCellDwellTime(currentTime, viewCondition) {
      const isVisible = isBlankCellVisible(viewCondition);
      
      if (isVisible && lastBlankCheckTime > 0) {
        blankCellDwellTime += currentTime - lastBlankCheckTime;
      }
      
      lastBlankCheckTime = currentTime;
      wasBlankCellVisible = isVisible;
    }

    // Scroll offset tracking for scroll condition
    let scrollOffsetX = 0;
    let scrollOffsetY = 0;

    // Draw search display based on view condition
    function drawSearchDisplay(ctx, viewCondition) {
      ctx.clearRect(0, 0, params.screenWidth, params.screenHeight);
      
      if (viewCondition !== 'fullscreen') {
        // Clip to window area
        const searchWindow = document.getElementById('search-window');
        const windowRect = searchWindow.getBoundingClientRect();
        
        ctx.save();
        ctx.beginPath();
        ctx.rect(windowRect.left, windowRect.top, windowRect.width, windowRect.height);
        ctx.clip();
      }
      
      // Draw all objects
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        drawObject(ctx, obj.x, obj.y, obj.size, obj.color, obj.shape);
      }
      
      if (viewCondition !== 'fullscreen') {
        ctx.restore();
      }
    }

    // Draw an object on the canvas
    function drawObject(ctx, x, y, size, color, shape) {
      ctx.fillStyle = color;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      
      switch (shape) {
        case 'circle':
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          break;
        case 'triangle':
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.lineTo(x - size / 2, y + size / 2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
        case 'square':
          ctx.beginPath();
          ctx.rect(x - size / 2, y - size / 2, size, size);
          ctx.fill();
          ctx.stroke();
          break;
        case 'diamond':
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x + size / 2, y);
          ctx.lineTo(x, y + size / 2);
          ctx.lineTo(x - size / 2, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
      }
    }

    // Feedback for visual search task
    const searchFeedback = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Get the last visual search task data specifically
        const searchData = jsPsych.data.get().filter({task: 'visual_search'}).last(1).values()[0];
        const correct = searchData.correct;
        const reactionTimeMs = searchData.reaction_time;
        const reactionTimeSec = (reactionTimeMs / 1000).toFixed(1);
        
        return `
          <h1>${correct ? '正解!' : '不正解'}</h1>
          <p style="font-size: 18px; margin-top: 20px;">今回のタイム：${reactionTimeSec}秒</p>
        `;
      },
      data: {
        task: 'search_feedback'
      },
      choices: "NO_KEYS",
      trial_duration: 1000
    };


    // Result screen with overall score
    const resultScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Calculate overall accuracy for visual search
        const searchData = jsPsych.data.get().filter({task: 'visual_search'});
        const correctSearches = searchData.filter({correct: true}).count();
        const searchAccuracy = Math.round((correctSearches / searchData.count()) * 100);
        
        // Calculate average response time for visual search
        const searchTimes = searchData.select('reaction_time').values;
        let avgSearchTimeSeconds = 0;
        if (searchTimes && searchTimes.length > 0) {
          // Filter out invalid values (null, undefined, NaN)
          const validTimes = searchTimes.filter(time => time != null && !isNaN(time) && time > 0);
          if (validTimes.length > 0) {
            const avgSearchTime = validTimes.reduce((a, b) => a + b, 0) / validTimes.length;
            avgSearchTimeSeconds = Math.floor((avgSearchTime / 1000) * 100) / 100; // Convert to seconds, truncate to 2 decimal places
          }
        }
        
        return `
          <div style="max-width: 700px; margin: 0 auto; padding: 40px 20px; text-align: center; line-height: 1.6;">
            <h1 style="color: #2c3e50; margin-bottom: 30px;">お疲れ様でした！</h1>
            
            <div style="background-color: #f8f9fa; padding: 30px; border-radius: 10px; margin: 30px 0;">
              <h2 style="color: #495057; margin-bottom: 20px;">実験結果</h2>
              <p style="font-size: 18px; margin: 15px 0;">図形探しの正答率：${searchAccuracy}％</p>
              <p style="font-size: 18px; margin: 15px 0;">図形探しのスピード：平均${avgSearchTimeSeconds}秒</p>
            </div>
            
            <div style="background-color: #e7f3ff; padding: 25px; border-radius: 10px; margin: 30px 0; text-align: left;">
              <h3 style="color: #0056b3; margin-bottom: 15px; text-align: center;">ご意見・ご感想</h3>
              <p style="font-size: 16px; margin-bottom: 15px; color: #333; text-align: center;">この実験について、ご意見や気づいた点などがあれば、ご自由に記載ください。何もなければ空欄のままで構いません。</p>
              <textarea id="experiment-comments" style="width: 100%; min-height: 120px; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box; font-family: 'Noto Sans JP', 'ヒラギノ角ゴ Pro', 'Hiragino Kaku Gothic Pro', 'メイリオ', Meiryo, sans-serif; resize: vertical;" placeholder="ご意見やご感想があれば、ご記入ください（任意）"></textarea>
            </div>
            
            <div style="margin: 30px 0;">
              <button id="result-screen-next-btn" style="padding: 15px 30px; font-size: 18px; background-color: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">次へ</button>
            </div>
          </div>
        `;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('result-screen-next-btn');
        nextBtn.addEventListener('click', function() {
          // Get the comments from the textarea
          const commentsTextarea = document.getElementById('experiment-comments');
          const comments = commentsTextarea ? commentsTextarea.value.trim() : '';
          
          // Store the comments in jsPsych data
          jsPsych.data.addProperties({
            experiment_comments: comments
          });
          
          // Finish the trial
          jsPsych.finishTrial();
        });
      }
    };

    // Final screen with confirmation ID
    const finalScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Generate random 6-digit confirmation ID
        const confirmationId = Math.floor(100000 + Math.random() * 900000).toString();
        
        // Store confirmation ID in data
        jsPsych.data.addProperties({
          confirmation_id: confirmationId
        });
        
        return `
          <div style="max-width: 800px; margin: 0 auto; padding: 40px 20px; text-align: center; line-height: 1.8;">
            <h1 style="color: #2c3e50; margin-bottom: 30px; font-size: 28px;">終了手順の説明</h1>
            
            <div style="background-color: #f8f9fa; border: 3px solid #007bff; border-radius: 15px; padding: 40px; margin: 30px 0;">
              <p style="font-size: 20px; margin-bottom: 15px; color: #495057; font-weight: bold;">あなたの確認用ID</p>
              <p style="font-size: 48px; font-weight: bold; color: #007bff; letter-spacing: 8px; margin: 20px 0;">${confirmationId}</p>
            </div>
            
            <div style="background-color: #e7f3ff; padding: 25px; border-radius: 10px; margin: 30px 0; text-align: left;">
              <h3 style="color: #0056b3; margin-bottom: 15px; text-align: center;">終了プロセスの説明</h3>
              <ul style="font-size: 18px; line-height: 1.8; padding-left: 20px; list-style-type: none;">
                <li style="margin: 15px 0;">✓ <strong>確認用IDを必ずメモしておいてください。</strong></li>
                <li style="margin: 15px 0;">✓ <strong>実験終了後に、クラウドワークスに確認用IDを入力してください。IDが正しい場合に謝礼をお支払いさせていただきます。</strong></li>
                <li style="margin: 15px 0;">✓ <strong>下の「データを送信する」ボタンを押して、実験を終了してください。</strong></li>
              </ul>
            </div>
            
            <div style="margin: 30px 0;">
              <button id="final-screen-submit-btn" style="padding: 15px 30px; font-size: 18px; background-color: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-weight: bold;">データを送信する</button>
            </div>
          </div>
        `;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Submit button
        const submitBtn = document.getElementById('final-screen-submit-btn');
        submitBtn.addEventListener('click', function() {
          // TODO: Add data sending process here (to be developed in future)
          jsPsych.finishTrial();
        });
      }
    };

    /* finish connection with pavlovia.org */
    /*
    var pavlovia_finish = {
      type: jsPsychPavlovia,
      command: "finish"
    };
    */

    // Completion screen after data submission
    const completionScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        return `
          <div style="max-width: 800px; margin: 0 auto; padding: 40px 20px; text-align: center; line-height: 1.8;">
            <div style="background-color: #d4edda; border: 3px solid #28a745; border-radius: 15px; padding: 40px; margin: 30px 0;">
              <h1 style="color: #155724; margin-bottom: 20px; font-size: 32px;">✓ データが正しく送信されました。</h1>
            </div>
            
            <div style="background-color: #f8f9fa; padding: 30px; border-radius: 10px; margin: 30px 0;">
              <p style="font-size: 20px; margin: 15px 0; color: #333;">これで実験は終了です。画面を閉じて構いません。ご協力いただきありがとうございました。</p>
            </div>
            
            <div style="background-color: #fff3cd; border: 2px solid #ffc107; border-radius: 10px; padding: 30px; margin: 30px 0;">
              <p style="font-size: 18px; margin: 15px 0; color: #856404; font-weight: bold;">クラウドワークスのページに、確認用IDを忘れずに入力してください。</p>
            </div>
          </div>
        `;
      },
      choices: "NO_KEYS"
    };

    // Practice completion choice screen
    const practiceCompletionChoice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 600px; margin: 0 auto; padding: 20px; text-align: center;">';
        html += '<h1>練習完了</h1>';
        html += '<p style="font-size: 18px; margin: 20px 0;">3回の練習が完了しました。</p>';
        html += '<p style="font-size: 16px; margin: 20px 0;">以下から選択してください：</p>';
        html += '<div style="margin: 30px 0;">';
        html += '<button id="practice-again-btn" style="padding: 15px 30px; font-size: 16px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px;">もう一度練習する</button>';
        html += '<button id="proceed-main-btn" style="padding: 15px 30px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px;">本番へ進む</button>';
        html += '</div>';
        html += '</div>';
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const practiceAgainBtn = document.getElementById('practice-again-btn');
        const proceedMainBtn = document.getElementById('proceed-main-btn');
        
        practiceAgainBtn.addEventListener('click', function() {
          jsPsych.finishTrial({
            choice: 'practice_again'
          });
        });
        
        proceedMainBtn.addEventListener('click', function() {
          jsPsych.finishTrial({
            choice: 'proceed_main'
          });
        });
      }
    };

    // Main experiment start notice
    const mainExperimentStart = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="max-width: 600px; margin: 0 auto; padding: 20px; text-align: center;">
          <h1>本番開始</h1>
          <p style="font-size: 18px; margin: 20px 0;">ここから本番です</p>
          <p style="font-size: 16px; margin: 20px 0;">
            練習で体験した内容と同じ課題を行います。<br>
            集中して取り組んでください。
          </p>
          <p style="font-size: 16px; margin: 20px 0;">
            <strong>下の「次へ」ボタンをクリックして本番を開始してください。</strong>
          </p>
          <div style="margin: 20px 0;">
            <button id="main-experiment-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">次へ</button>
          </div>
        </div>
      `,
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('main-experiment-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Break page shown after 30 trials (halfway point)
    const breakPage = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="max-width: 600px; margin: 0 auto; padding: 20px; text-align: center;">
          <h1>休憩</h1>
          <p style="font-size: 18px; margin: 20px 0;">半分終了です。</p>
          <p style="font-size: 16px; margin: 20px 0;">
            数分の休憩をとって構いません。<br>
            準備ができましたら、次へボタンを押して後半を開始してください。
          </p>
          <div style="margin: 20px 0;">
            <button id="break-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">次へ</button>
          </div>
        </div>
      `,
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('break-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };


    // Generate practice trial variables
    // 3 trials total, all using the assigned view condition with structured placement
    const practiceTrialVariables = [
      { viewCondition: assignedViewCondition, structure: 'structured', isPractice: true },
      { viewCondition: assignedViewCondition, structure: 'structured', isPractice: true },
      { viewCondition: assignedViewCondition, structure: 'structured', isPractice: true }
    ];

    // Create factorial design for structure only (viewCondition is fixed to assigned condition)
    // 4 structure conditions × 15 trials each = 60 total main trials
    const structureFactors = {
      structure: ['structured', 'aligned_random', 'blank_5', 'blank_10']
    };
    
    // Generate trial design - 15 trials per structure condition = 60 total
    const trialDesign = jsPsych.randomization.factorial(structureFactors, params.trialsPerCondition);
    trialDesign.forEach(trial => {
      trial.viewCondition = assignedViewCondition; // Use assigned view condition
      trial.isPractice = false;
    });
    
    // Build timeline procedure for a single trial (simplified without memory/position tasks)
    const trialProcedure = {
      timeline: [
        visualSearchInstructions,
        blankScreen,
        showTarget,
        blankScreen,
        visualSearch,
        searchFeedback
      ]
    };
    
    // Practice trial procedure - simplified version
    const practiceTrialProcedure = {
      timeline: [
        visualSearchInstructions,
        blankScreen,
        showTarget,
        blankScreen,
        visualSearch,
        searchFeedback
      ]
    };

    // Practice block procedure
    const practiceBlockProcedure = {
      ...practiceTrialProcedure,
      timeline_variables: practiceTrialVariables,
      randomize_order: false // Keep fixed order for practice
    };

    // Complete practice procedure with loop
    const practiceProcedure = {
      timeline: [
        practiceBlockProcedure,
        practiceCompletionChoice,
        {
          timeline: [practiceBlockProcedure],
          conditional_function: function() {
            // Check if user chose to practice again
            const lastChoice = jsPsych.data.get().last(1).values()[0];
            return lastChoice.choice === 'practice_again';
          }
        }
      ],
      loop_function: function() {
        // Check if user chose to practice again
        const lastChoice = jsPsych.data.get().last(1).values()[0];
        return lastChoice.choice === 'practice_again';
      }
    };

    // Shuffle trial design and split into two halves for break
    const shuffledTrialDesign = jsPsych.randomization.shuffle(trialDesign);
    const firstHalfTrials = shuffledTrialDesign.slice(0, 30);
    const secondHalfTrials = shuffledTrialDesign.slice(30);

    // First half block procedure (30 trials)
    const firstHalfBlockProcedure = {
      ...trialProcedure,
      timeline_variables: firstHalfTrials,
      randomize_order: false // Already shuffled
    };

    // Second half block procedure (30 trials)
    const secondHalfBlockProcedure = {
      ...trialProcedure,
      timeline_variables: secondHalfTrials,
      randomize_order: false // Already shuffled
    };

    // Full experiment timeline (simplified without memory/position tasks)
    const timeline = [
      //pavlovia_init,
      welcome,
      informedConsent,
      demographics,
      checkPage,
      initialExplanation,
      practiceProcedure,
      mainExperimentStart,
      firstHalfBlockProcedure,
      breakPage,
      secondHalfBlockProcedure,
      resultScreen,
      finalScreen,
      //pavlovia_finish,
      completionScreen
    ];

    // Run the experiment using jsPsych v7 API (upgraded from v6.3.1)
    jsPsych.run(timeline);
  </script>
</body>
</html>
